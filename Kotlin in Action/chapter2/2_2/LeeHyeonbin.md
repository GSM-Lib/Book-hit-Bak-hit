# 2.2 클래스와 프로퍼티
오늘은 클래스를 선언하는 기본 문법에 대해서 다뤄보겠습니다.
코틀린과 자바를 비교해보기 위해 먼저 간단한 자바의 Person 클래스를 만들어보겠습니다.
```java
public class Person{
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```
위와 같은 식으로 필드와 getter, setter를 사용하였습니다.
하지만 위와 같은 코드는 필드가 둘 이상으로 늘어나면 대입문의 수도 늘어나게됩니다.

코틀린에서는 자바보다 훨씬 적은 로직으로 작성할 수 있습니다.

코틀린으로 위 코드를 작성한다면
```kotlin
class Person(val name: String)
```

위 코드처럼 매우 간결하게 작성할 수 있습니다.

> 다른 최근 JVM에서 위처럼 작성하는 코드(코드가 없이 데이터만 저장하는 클래스)를 값 객체 value object 라고 합니다. 

위의 코드를 조금 살펴보자면 자바의 public 키워드가 사라졌습니다.
코틀린에서는 기본 가시성이 public이기 때문에 따로 키워드를 넣어주지 않아도 됩니다.

그렇다면 코틀린에서는 어떻게 위처럼 코드를 작성할 수 있었을까요?

## 2.2.1 프로퍼티
클래스라는 개념의 목적은 데이터를 캡슐화 encapsulate하고 캡슐화 한 데이터를 다루는 코드를 한 주체 아래 가두는 것입니다.

자바에서는 데이터를 필드 field에 저장하고, 멤버 필드의 가시성은 private으로 두어 사용합니다. 자신에 접근하기 위해선 자신을 사용하는 곳에서 데이터에 접근할 수 있는 통로로 사용할 수 있는 접근자 메서드를 제공합니다.

위의 Person 클래스를 보시면 자바에서는
필드를 읽기 위해선 getter, 필드 변경을 위해서는 setter를 사용하는 것을 알 수 있습니다.

자바에서는 필드와 접근자를 묶어서 프로퍼티라고 부릅니다.

하지만 코틀린은 프로퍼티를 언어 기본 기능으로 제공합니다. 또한 자바의 필드와 접근자 메서드를 완전히 대신할 수 있습니다.

앞에서 나왔던 것처럼 코틀린에서는 val과 var을 사용하여 선언해줄 수 있습니다.
val로 선언한 프로퍼티는 읽기 전용이며, var로 선언한 프로퍼티는 값을 변경할 수도 있습니다.

코틀린에서 만약
```kotlin
class Person(val name: String, val isFat: Boolean)
```

라는 식으로 클래스를 생성한다면,
name이라는 비공개 필드와 공개 getter를 생성해주고,
isFat이라는 비공개 필드와 공개 getter와 공개 setter를 생성해줍니다.

위와 같은 코틀린 코드는 자바와 같은 구현이 숨어져있습니다.

처음에 코틀린과 자바는 혼용해서 사용할 수 있다고 설명한 적이 있습니다.

그렇다면 언어와 관계 없이 저 클래스를 사용할 수 있는 것일까요??

자바에서 사용해보겠습니다.
```java
Person person = new Person("김현승", true);
System.out.println(person.getName())
// 김현승
System.out.println(person.isFat())
// true
```

위와 같은 형식으로 코틀린의 name이라는 프로퍼티는 getName()이라는 이름으로 접근할 수 있습니다. 하지만 게터와 세터의 이름을 지정하는 것은 예외가 존재합니다.

이름이 is로 시작하는 경우에는 get이 붙지 않고 세터에는 is를 set으로 변경한 이름으로 사용할 수 있습니다.

```kotlin
val person = Person("김현승", true)
println(person.name)
// 김현승
println(person.isFat)
// true
```
코틀린에서는 프로퍼티를 직접 사용한 듯 하지만, 
코틀린이 자동으로 게터를 호출해줍니다.

또한 로직은 동일하지만 코드는 훨씬 간결해졌습니다.

그렇다면 세터는 어떻게 사용할까요?

만약 현승이가 다이어트를 해서 fat이 아닌 상태가 되었을 때 true를 false로 변경해봅시다.
```java
person.setFat(false)
```

```kotlin
person.isFat = false
```

코틀린에서 사용했던 클래스에 대해 자바를 사용했듯이 자바에서 선언한 클래스에도 코틀린 문법을 사용할 수 있습니다.

대부분의 프로퍼티에는 그 프로퍼티의 값을 저장하기 위한 필드가 있습니다. 이러한 필드를 백킹 필드라고 부릅니다. 하지만 원하는 경우에는 프로퍼티 값을 그때 그때 계산할 수 있는 커스텀 게터를 작성할 수도 있습니다.

## 2.2.2 커스텀 접근자
이번 부분에서는 프로퍼티의 접근자를 직접 작성하는 방법에 대해 알아보겠습니다.

만약 직사각형 클래스인 Rectangle을 정의하면서 자신이 정사각형인지 알려주는 기능을 만들어보겠습니다. 직사각형이 정사각형인지 별도의 필드를 저장할 필요 없이 그때 그때 확인할 수 있습니다.

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }
}
```

```kotlin
val rectangle = Rectangle(41, 43)
println(rectangle.isSquare)
// false
```
위와 같은 코드를 작성하면
isSquare을 호출할 때마다 블록 안에 있는 코드를 실행시켜 확인하고, 해당 값을 리턴합니다.

### 위처럼 커스텀 게터를 사용하면 성능상에 문제가 있을까?
그냥 게터를 사용하던 커스텀 게터를 사용하든 큰 차이는 없다.
차이가 나는 부분은 가독성 뿐이라고 이야기합니다.

## 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지
자바의 경우 모든 클래스를 패키지 단위로 관리합니다.

코틀린에서도 자바와 비슷한 개념의 패키지가 있습니다. 코틀린 파일의 맨 앞에 package 문을 넣을 수 있습니다. 그러면 그 파일 안에 있는 모든 선언이 해당 패키지에 들어갑니다. 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있습니다. 

하지만 패키지가 다르다면 임포트를 통해 선언을 불러와야 합니다. 

자바와 마찬가지로 임포트문은 파일의 맨 앞에 와야 합니다.
또한 import 키워드를 사용합니다.

또한 패키지 이름 뒤에 *을 추가하면 패키지 안에 있는 모든 선언을 임포트할 수 있습니다.

자바에서는 클래스별로 파일을 분류하여,
패키지 안에 클래스를 넣고 세부적인 클래스가 있다면 모든 파일들을 해당 디렉터리 안에 넣어야하는 형태였습니다.

하지만 코틀린에서는 여러 클래스를 한 파일이 넣어서 파일의 이름도 맘대로 지정하여 사용할 수 있습니다. 

하지만 이는 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫습니다.
자바의 코드를 코틀린으로 마이그레이션 하는 작업 등에서 문제가 생길 수도 있고, 

책에 나온 내용은 아니지만, 프로젝트를 진행하며, 많은 클래스를 한 파일에다가 두었을 경우에 파일을 찾는 곳에서도 문제가 있었고 관리 하는 방면에서도 좋지 않았던 경험이 있기에 작은 단위별로 나누는 것을 추천합니다.